<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adaptive resampling · SequentialMonteCarlo.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SequentialMonteCarlo.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Contents</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../smcintegrals/">SMC integrals</a></li><li><a class="tocitem" href="../smcalgorithm/">SMC algorithm</a></li><li><a class="tocitem" href="../smctheory/">Theoretical properties</a></li><li><a class="tocitem" href="../smcve/">Variance estimators</a></li><li class="is-active"><a class="tocitem" href>Adaptive resampling</a><ul class="internal"><li><a class="tocitem" href="#(Relative)-effective-sample-size"><span>(Relative) effective sample size</span></a></li><li><a class="tocitem" href="#Adaptive-resampling-algorithm"><span>Adaptive resampling algorithm</span></a></li><li><a class="tocitem" href="#Particle-approximations"><span>Particle approximations</span></a></li><li><a class="tocitem" href="#Variance-estimation"><span>Variance estimation</span></a></li></ul></li><li><a class="tocitem" href="../csmc/">Conditional SMC</a></li><li><a class="tocitem" href="../impl/">Implementation notes</a></li><li><a class="tocitem" href="../performance/">Performance tips</a></li><li><a class="tocitem" href="../smcinterface/">SMC interface</a></li><li><a class="tocitem" href="../guide/">Types and functions</a></li><li><a class="tocitem" href="../hmm/">Hidden Markov models</a></li><li><a class="tocitem" href="../bench/">Benchmarks</a></li><li><a class="tocitem" href="../refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Adaptive resampling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adaptive resampling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/master/docs/src/smcadaptive.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="adaptiveresampling"><a class="docs-heading-anchor" href="#adaptiveresampling">SMC with adaptive resampling</a><a id="adaptiveresampling-1"></a><a class="docs-heading-anchor-permalink" href="#adaptiveresampling" title="Permalink"></a></h1><p>There is a tuning parameter associated with the <code>SequentialMonteCarlo.smc</code> algorithm that results in an adaptive version of the <a href="../smcalgorithm/#basicsmc">SMC Algorithm</a>. This is the <code>essThreshold</code> parameter, whose use was proposed by Kong et al. (1994) and Liu &amp; Chen (1995). We represent this parameter as <span>$\tau$</span> below.</p><h2 id="(Relative)-effective-sample-size"><a class="docs-heading-anchor" href="#(Relative)-effective-sample-size">(Relative) effective sample size</a><a id="(Relative)-effective-sample-size-1"></a><a class="docs-heading-anchor-permalink" href="#(Relative)-effective-sample-size" title="Permalink"></a></h2><p>The adaptive SMC algorithm essentially involves choosing <span>$(A_{p-1}^{1}, \ldots, A_{p-1}^N) = \left(1, \ldots, N \right)$</span> when the <em>weights</em> associated with particles <span>$\zeta_{p-1}^{1}, \ldots, \zeta_{p-1}^N$</span> have a <em>relative effective sample size</em> exceeding <span>$\tau$</span>. This is sometimes referred to as &quot;not resampling&quot;. The relative effective sample size of a collection of weights is defined as</p><p class="math-container">\[{\rm rESS}(w_{1}, \ldots, w_{N}) := \frac{\left(\frac{1}{N}\sum_{i=1}^N w_{i} \right)^{2}}{\frac{1}{N} \sum_{i=1}^N w_{i}^{2}}.\]</p><p>This function is invariant to rescaling of all of the weights by a common constant.</p><p>In the <a href="../smcalgorithm/#basicsmc">SMC Algorithm</a> we can view the weights associated with the particles <span>$\zeta_{p-1}^{1}, \ldots, \zeta_{p-1}^N$</span> as being <span>$W_{p-1}^{1}, \ldots, W_{p-1}^N$</span> where <span>$W_{p-1}^{i} \propto G_{p-1}(\zeta_{p-1}^{i})$</span>, and their relative effective sample size is <span>${\rm rESS}(W_{p-1}^{1}, \ldots, W_{p-1}^N)$</span>.</p><p>In the SMC with adaptive resampling algorithm, the weight of a particle may be proportional to a product of many potential function values, depending on when the most recent normal resampling step was. In particular, whenever the standard resampling step is not taken, particles first inherit the weights of their ancestors and then multiply them by their own potential function values. The algorithm is as follows:</p><h2 id="Adaptive-resampling-algorithm"><a class="docs-heading-anchor" href="#Adaptive-resampling-algorithm">Adaptive resampling algorithm</a><a id="Adaptive-resampling-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-resampling-algorithm" title="Permalink"></a></h2><ol><li><p>Sample <span>$\zeta_{1}^{i} \overset{\mathrm{i.i.d.}}{\sim} M_{1}$</span> and compute <span>$W_{1}^{i} \propto G_{1}(\zeta_{1}^{i})$</span> for <span>$i\in \{1, \ldots, N\}$</span>.</p></li><li><p>For <span>$p=2,\ldots,n$</span>:</p><ul><li><p>compute <span>$\mathcal{E}_{p-1}^N := {\rm rESS}(W_{p-1}^{1},\ldots,W_{p-1}^N)$</span>.</p></li><li><p>if <span>$p = n$</span> or <span>$\mathcal{E}_{p-1}^N \leq \tau$</span> set <span>$R_{p-1} \leftarrow 1$</span>; otherwise set <span>$R_{p-1} \leftarrow 0$</span>.</p></li><li><p>if <span>$R_{p-1} = 1$</span>, sample a vector <span>$A_{p-1}^{1}, \ldots, A_{p-1}^N$</span> of i.i.d. <span>${\rm Categorical}(W_{p-1}^{1}, \ldots, W_{p-1}^N)$</span> random variables in increasing order; otherwise set <span>$(A_{p-1}^{1}, \ldots, A_{p-1}^N) = \left(1, \ldots, N \right)$</span>.</p></li><li><p>sample <span>$\zeta_{p}^{i} \overset{\mathrm{ind}}{\sim} M_{p}(\zeta_{p-1}^{A_{p-1}^{i}}, \cdot)$</span> and compute <span>$W_{p}^{i} \propto \left(W_{p-1}^{i} \right)^{\mathbb{I}(R_{p-1} = 0)} G_{p}(\zeta_{p}^{i})$</span> for <span>$i\in \{1,\ldots,N\}$</span>.</p></li></ul></li></ol><hr/><p>Note that the time <span>$n-1$</span> particles are always resampled, so that <span>$\eta_{n}^N$</span> is always an unweighted particle approximation of <span>$\eta_{n}$</span>. This is primarily an implementation detail.</p><h2 id="Particle-approximations"><a class="docs-heading-anchor" href="#Particle-approximations">Particle approximations</a><a id="Particle-approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-approximations" title="Permalink"></a></h2><p>We define</p><p class="math-container">\[\eta_{p}^N \propto \sum_{i=1}^N \left(W_{p-1}^{i} \right)^{ \mathbb{I}(R_{p-1} = 0)} \delta_{\zeta_{p}^{i}}, \qquad p \in \{1,\ldots,n\},\]</p><p>and</p><p class="math-container">\[\hat{\eta}_{p}^N \propto \sum_{i=1}^N W_{p}^{i} \delta_{\zeta_{p}^{i}}, \qquad p \in \{1,\ldots,n\}.\]</p><p>Appropriate approximations of <span>$\hat{Z}_{1}^N, \ldots, \hat{Z}_{n}^N$</span> are also well-defined, but tedious to display.</p><p>These particle approximations all enjoy the same <a href="../smctheory/#maintheory">theoretical properties</a> stated for the standard SMC Algorithm, although the asymptotic variance maps <span>$\sigma^2_p$</span> are generally different. In fact, adaptive resampling improves in certain scenarios the quality of SMC approximations; its effects have been studied theoretically by Del Moral et al. (2010) and Whiteley et al. (2016).</p><h2 id="Variance-estimation"><a class="docs-heading-anchor" href="#Variance-estimation">Variance estimation</a><a id="Variance-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Variance-estimation" title="Permalink"></a></h2><p>All of the methods described in <a href="../smcinterface/#Variance-estimators">Variance estimators</a> can be run on output from the SMC with adaptive resampling algorithm.</p><p>One should be aware that the length of the vector returned by <code>SequentialMonteCarlo.vpns</code> will be of length <span>$m = 1 + \sum_{i=1}^{n-1} R_i \leq n$</span>. This is a consequence of the fact that resampling only at certain times can be viewed as running an SMC algorithm with modified Markov kernels and potential functions defined on a more complicated state space –- the details are not presented here –- so that the number of terms in the asymptotic variance decomposition is <span>$m$</span> and not (necessarily) <span>$n$</span>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../smcve/">« Variance estimators</a><a class="docs-footer-nextpage" href="../csmc/">Conditional SMC »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Friday 3 September 2021 13:53">Friday 3 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
